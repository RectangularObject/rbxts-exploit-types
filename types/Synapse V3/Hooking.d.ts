// noinspection JSUnusedGlobalSymbols

declare interface SynapseMetatable extends LuaMetatable<unknown> {
	__namecall: (self: unknown, ...args: unknown[]) => unknown;
}

/** Hides or unhides a function from the callstack. */
declare function setstackhidden(closure: Callback, hidden?: boolean): void;
/** Hides or unhides a function (indicated by `level`) in the callstack. */
declare function setstackhidden(level: number, hidden?: boolean): void;
/** Creates a C wrapper around `closure` with function name `name` if provided. */
declare function newcclosure(closure: Callback, name?: string): Callback;
/** Clones a function. Note that if the function passed is a C closure, `is_synapse_function` will return true on the returned closure. */
declare function clonefunction(to_clone: Callback): Callback;
/** Hooks a Lua or C function in-place. Returns a copy of the original function. Can optionally specify a filter to use. */
declare function hookfunction(to_hook: Callback, hook: Callback, filter?: Filter): Callback;
/** Hooks a Lua function prototype. Prototypes can only be hooked once! */
declare function hookproto(to_hook: ProtoProxy, hook: Callback): void;
/** TODO */
declare function hookmetamethod<UD, K extends keyof SynapseMetatable, V extends SynapseMetatable[K]>(to_hook: UD, metamethod: K, hook: V, arg_guard?: boolean, filter?: Filter): (...data: Parameters<V>) => ReturnType<V>;
/** Un-hooks a function hooked with {@link hookfunction}. */
declare function restorefunction(to_restore: Callback): void;
/** Returns true if f is hooked by {@link hookfunction}, {@link hookmetamethod}, or {@link syn.oth.hook}. */
declare function isfunctionhooked(f: Callback): boolean;
/** TODO */
declare function restoreproto(to_restore: ProtoProxy): void;
/** Enables the interception of signal invocations. When `signal` is fired, `callback` is called for every Lua connection in `signal` with an info table and the invocation arguments. Returning true from this callback fires the original connection. For now, the callback should not yield. `hooksignal` cannot be used to intercept C (engine) connections or Lua connections belonging to CoreScripts. */
declare function hooksignal(signal: RBXScriptSignal, callback: Callback): void;
/** Unhooks a signal hooked with {@link hooksignal}. */
declare function restoresignal(signal: RBXScriptSignal): void;
/** Returns true if `signal` is hooked. */
declare function issignalhooked(signal: RBXScriptSignal): void;
/**Returns the namecall method if the function is called in an __namecall metatable hook. */
declare function getnamecallmethod(): string;
