// noinspection JSUnusedGlobalSymbols

declare namespace syn {
  namespace crypt {
    namespace base64 {
      /** Base64 encodes `input`. */
      function encode(input: string): string;
      /** Base64 decodes `input`. */
      function decode(input: string): string;
    }
    namespace hex {
      /** Encodes `input` in hexadecimal. */
      function encode(input: string): string;
      /** Decodes `input` in hexadecimal. */
      function decode(input: string): string;
    }
    namespace lz4 {
      /** Compresses `data` with LZ4. */
      function compress(data: string): string;
    }
    namespace derive {
      /** Derives a cryptographic key from another `key` specified - `len` specifies the length of the generated key, `sub_key_id` is the index of the key to generate, and `context` is an 8-byte string that uniquely identifies the script that is generating this key.
       *
       * The `context` string can be any 8 ASCII characters. Some examples are `SynapseX`, `MyScript`, and `_Script_`.
       *
       * *Note*: Due to Lua's usage of 64 bit floating point numbers, the maximum safe integer to pass to `sub_key_id` is 2^52. Passing a larger number will result in undefined behavior.
       *
       * (Uses libsodium [key derivation]{@link https://libsodium.gitbook.io/doc/key_derivation}.)
       */
      function key(len: number, key: string, sub_key_id: number, context: string): string;
      /** Alternatively, you can derive a cryptographic key from `key` with `len` length from a simple ID passed into `id`. This can be a message of any length.
       *
       * (Uses libsodium [generic hashing]{@link https://libsodium.gitbook.io/doc/hashing/generic_hashing}, with the `key` being used for a keyed hash.)
       */
      function key(len: number, key: string, id: string): string;
      /** Derives a cryptographic key from a user-entered `password`. Due to passwords usually being low-complexity and easy to crack, this function uses a *password hashing function* to achieve its goals.
       *
       * In order to use this function, you must pass a 16-byte `salt`. You can generate this via `syn.crypt.random`.
       *
       * Password hashing functions are deliberately slow - this is to make bruteforce attacks harder. The `mode` (or `opslimit/memlimit`) parameter allows you to specify how much security you want your derived key to have. You should choose the mode you wish to use based on how acceptable the wait for function completion is for your application, and what the security requirements for your application are.
       *
       * **Warning**: Using the higher security PasswordDerivationMode options (or a memlimit parameter higher than 512MiB) with more than one password hash being processed at once can cause crashes due to high-memory requirements for the hash function.
       *
       * (Uses libsodium [password hashing]{@link https://libsodium.gitbook.io/doc/password_hashing/default_phf}.)
       *
       * **PasswordDerivationMode**
       * |Mode         |Note                                                                                                                          |
       * |:-----------:|:----------------------------------------------------------------------------------------------------------------------------:|
       * |`Interactive`|The password hash takes ~100 milliseconds to complete on a modern PC.                                                         |
       * |`Moderate`   |The password hash takes ~1 second to complete on a modern PC.                                                                 |
       * |`Sensitive`  |The password hash takes ~5 seconds to complete on a modern PC. Please note the warning above, as it particularly affects this.|
       */
      function password(len: number, password: string, salt: string, mode: PasswordDerivationMode): string;
      /** Derives a cryptographic key from a user-entered `password`. Due to passwords usually being low-complexity and easy to crack, this function uses a *password hashing function* to achieve its goals.
       *
       * In order to use this function, you must pass a 16-byte `salt`. You can generate this via `syn.crypt.random`.
       *
       * Password hashing functions are deliberately slow - this is to make bruteforce attacks harder. The `mode` (or `opslimit/memlimit`) parameter allows you to specify how much security you want your derived key to have. You should choose the mode you wish to use based on how acceptable the wait for function completion is for your application, and what the security requirements for your application are.
       *
       * **Warning**: Using the higher security PasswordDerivationMode options (or a memlimit parameter higher than 512MiB) with more than one password hash being processed at once can cause crashes due to high-memory requirements for the hash function.
       *
       * (Uses libsodium [password hashing]{@link https://libsodium.gitbook.io/doc/password_hashing/default_phf}.)
       *
       * **PasswordDerivationMode**
       * |Mode         |Note                                                                                                                          |
       * |:-----------:|:----------------------------------------------------------------------------------------------------------------------------:|
       * |`Interactive`|The password hash takes ~100 milliseconds to complete on a modern PC.                                                         |
       * |`Moderate`   |The password hash takes ~1 second to complete on a modern PC.                                                                 |
       * |`Sensitive`  |The password hash takes ~5 seconds to complete on a modern PC. Please note the warning above, as it particularly affects this.|
       */
      function password(len: number, password: string, salt: string, ops_limit: number, mem_limit: number): string;
    }
    namespace user {
      /** All Per-User APIs also have a prompting equivalent under the `syn.crypt.user.prompt` table. These functions make a verification box asking the user to authenticate the request made by the script, and only return the data if the user accepts. This is more useful for more 'high security' data that you don't want cryptographic operations performed on by an unauthorized script.
       *
       * All of these functions yield as well, with the exclusion of `syn.crypt.user.prompt.verify` which does not need to be authenticated by the user.
       */
      namespace prompt {
        /** Prompt equivalent to {@link syn.crypt.user.encrypt}. */
        function encrypt(data: string, mode: UserEncryptionMode, key?: string): string;
        /** Prompt equivalent to {@link syn.crypt.user.decrypt}. */
        function decrypt(ciphertext: string, key?: string): string;
        /** Prompt equivalent to {@link syn.crypt.user.sign}. */
        function sign(data: string): string;
        /** Prompt equivalent to {@link syn.crypt.user.verify}. */
        function verify(data: string, signature: string): boolean;
      }
      /** Encrypts `data` in a way that only the caller's Synapse X account can decrypt it. You can also pass a `key` to add a secondary key to the encryption if you wish.
       *
       * *Note*: If the user resets their Synapse X password, **the output of this function will not be decryptable anymore**. The user simply changing their password when they know their current one will **not** cause this to happen, however.
       *
       * The `mode` parameter controls how the encryption works.
       *
       * **UserEncryptionMode**
       * |Mode            |Note                                                                                                                                                                                                                 |
       * |:--------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
       * |`SynAccount`    |Ties the encrypted data to the users Synapse X account. The data **is** decryptable on other machines if the pre-conditions stated above are met.                                                                    |
       * |`WindowsAccount`|Ties the encrypted data to *both* the users Synapse X account and Windows account. The data is *only* decryptable if both the pre-conditions stated above are met and the user does not reset their Windows password.|
       * |`WindowsMachine`|Ties the encrypted data to *both* the users Synapse X account and Windows machine. The data is *only* decryptable if both the pre-conditions stated above are met and the user does not reset their Windows PC.      |
       */
      function encrypt(data: string, mode: UserEncryptionMode, key?: string): string;
      /** Decrypts `ciphertext` from the *Per-User Encrypt* function above. You do not need to pass the `UserEncryptionMode` you used to encrypt this data, but you need to pass the `key` you used to encrypt the data if one was specified. The function will error if decryption fails. */
      function decrypt(ciphertext: string, key?: string): string;
      /** Signs `data` in a way that only the caller's Synapse X account can produce this signature. Equivalent to `syn.crypt.sign.detached.create` with a user-unique key.
       *
       * You can verify data was signed with this method from a web request. See [the HTTP APIs]{@link https://synllc.github.io/synapse-x-documentation/reference/category/http.html} for more information.
       */
      function sign(data: string): string;
      /** Verifies `data` was signed by the `syn.crypt.user.sign` function from the caller's Synapse X account. If you want to verify data signed by another user, get their public key from [the HTTP APIs]{@link https://synllc.github.io/synapse-x-documentation/reference/category/http.html}. */
      function verify(data: string, signature: string): boolean;
    }
    namespace seal {
      /** Generates a new public & secret keypair, and returns it in that order. */
      function keygen(): LuaTuple<[string, string]>;
      /** TODO */
      function derive(key: string): LuaTuple<[string, string]>;
      /** Encrypts `data` with the `public_key`. The data can only be later decrypted via the secret key in the keypair. */
      function encrypt(plaintext: string, public_key: string): string;
      /** Decrypts `data` with the `public_key` and `secret_key`. */
      function decrypt(ciphertext: string, public_key: string, secret_key: string): string;
    }
    namespace sign {
      namespace detached {
        /** Creates a signature for `data` with the `secret_key`, and returns the signature. */
        function create(data: string, secret_key: string): string;
        /** Verifies the `data` passed in with the `public_key` and `signature`, and returns `true` if the verification succeeds. Returns `false` if verification fails. */
        function verify(data: string, signature: string, public_key: string): boolean;
      }
      /** Generates a new public & secret keypair, and returns it in that order.
       *
       * **NOTE**; These keypairs are *NOT* compatible with the ones used for the encryption library above.
       */
      function keygen(): LuaTuple<[string, string]>;
      /** TODO */
      function derive(key: string): LuaTuple<[string, string]>;
      /** Creates a signature for `data` with the `secret_key`, and returns the signature combined with the message. */
      function create(data: string, secret_key: string): string;
      /** Verifies the `data` passed in with the `public_key`, and returns the original message if the verification succeeds. Errors if verification fails. */
      function open(data: string, public_key: string): string;
    }
    namespace custom {
      /** Encrypts data with key using selected cipher and iv/nonce. */
      function encrypt(cipher: string, data: string, key: string, iv: string): string;
      /** Decrypts ciphertext with key using selected cipher and iv/nonce. */
      function decrypt(cipher: string, data: string, key: string, iv: string): string;
      /** Hashes data with algorithm.
       *
       * **Custom Hashing Algorithms**
       * |MD5|SHA1|SHA2  |SHA3    |BLAKE  |
       * |:-:|:--:|:----:|:------:|:-----:|
       * |md5|sha1|sha224|sha3-224|blake2b|
       * |.  |.   |sha256|sha3-256|blake2s|
       * |.  |.   |sha384|sha3-384|.      |
       * |.  |.   |sha512|sha3-512|.      |
       */
      function hash(cipher: string, data: string): string;
      /** Creates a HMAC signature from data and key with algorithm.
       *
       * **Custom HMAC Algorithms**
       * |MD5|SHA1|SHA2  |SHA3    |
       * |:-:|:--:|:----:|:------:|
       * |md5|sha1|sha256|sha3-224|
       * |.  |.   |sha384|sha3-256|
       * |.  |.   |sha512|sha3-384|
       * |.  |.   |.     |sha3-512|
       */
      function hmac(cipher: string, data: string, key: string): string;
    }
    namespace url {
      function encode(data: string): string;
      function decode(data: string): string;
    }
    /** Encrypts `data` with `key`, and includes `additional_data` if it is passed.
     *
     * (Uses libsodium [secretbox]{@link https://libsodium.gitbook.io/doc/secret-key_cryptography/secretbox} for when additional_data isn't passed, and [the AEAD form of the same algorithm]{@link https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction} if it is passed. Nonce is generated and appended before the encrypted message.)
     */
    function encrypt(data: string, key: string, additional_data?: string): string;
    /** Decrypts `ciphertext` with key. The data (along with `additional_data` if it is passed) is also authenticated via a MAC before being returned.
     * (Uses libsodium [secretbox]{@link https://libsodium.gitbook.io/doc/secret-key_cryptography/secretbox} or [the AEAD form]{@link https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction} if `additional_data` is passed, like above.)
     */
    function decrypt(ciphertext: string, key: string, additional_data?: string): string;
    /** Hashes `data` with Blake2B. Optionally, you can pass `key` to create a 'keyed' hash, for which the hash will never be the same for different keys.
     * (Uses libsodium [generic hashing]{@link https://libsodium.gitbook.io/doc/hashing/generic_hashing}.)
     */
    function hash(data: string, key?: string): string;
    /** Creates a HMAC signature from `data` and `key`. Note this is not the same as passing a `key` to the above function, and uses a different algorithm.
     * (Uses libsodium [authentication]{@link https://libsodium.gitbook.io/doc/secret-key_cryptography/secret-key_authentication}.)
     */
    function hmac(data: string, key: string): string;
    /** Generates a random string with `size` (cannot be negative or exceed 1024). */
    function random(len: number): string;
  }
  namespace oth {
    /** A secure version of hookfunction for C functions that works by running hook code on separate threads. When a hooked function is called, a new or cached hook thread is resumed with the hook and any passed arguments. The returned callback can be used to execute the original function on the original, calling thread.
     *
     * In the context of a hook thread, the following functions behave as though being called under the original thread:
     * * getnamecallmethod
     * * setnamecallmethod
     * * checkcaller
     * * checkcallstack
     * * getcallingscript
     * * the debug library (debug.*)
     * * TODO
     */
    function hook(target: Callback, hook: Callback): Callback;
    /** Un-hooks a function hooked with {@link syn.oth.hook}. The second parameter is not required if the function has only been hooked once. Returns true upon success. */
    function unhook(target: Callback, hook_or_callback?: Callback): boolean;
    /** Returns a function that can be used to call the original function in the context of a hook thread. Useful for when a function is hooked multiple times and the callback you receive from {@link syn.oth.hook} executes the next hook in the chain, not the original function. */
    function get_root_callback(): Callback;
    /** Returns true if this thread is a hook thread. */
    function is_hook_thread(): boolean;
    /** Return the original thread this hook comes from, or nil if the current thread is not a hook. */
    function get_original_thread(): thread;
  }
  /** Removes all queued scripts from the teleport queue. */
  function queue_on_teleport(script: string): void;
  /** Returns the current thread's context level. */
  function clear_teleport_queue(): void;
  /** Sets the current thread's context level. */
  function get_thread_identity(): number;
  /** @deprecated Use {@link gethui} instead
   * @description For backwards compatability, this function will cause `target` to be parented the return value of `gethui()` the next time it is parented.
   */
  function protect_gui(target: Instance): void;
  /** @deprecated Use {@link gethui} instead
   * @description For backwards compatability, this function will disable the parent-redirection done by protect_gui.
   */
  function unprotect_gui(target: Instance): void;
  /** Proxy a call to a Lua function with the given call stack and thread options. `call_stack` is an array of tables, with each sub-table having fields described below.
   *
   * The thread parameter allows you to preset the `script`, `identity`, and `env` fields with the values from that thread. This field is optional, and those fields can be overridden after the fact.
   *
   * **Note:** These values do *not* need to correlate with actual information returned by debug.getinfo; they are fully customizable.
   *
   * **Note:** The `func` parameter will override all other data you pass here aside from `currentline`.
   * |Call Stack Entry|Description                                    |
   * |:--------------:|:---------------------------------------------:|
   * |currentline     |The currently executing line of code.          |
   * |env             |The function's environment.                    |
   * |source          |The 'source' field returned by debug.getinfo.  |
   * |name            |The function's name.                           |
   * |numparams       |The number of parameters in the function.      |
   * |is_vararg       |Whether this function takes variadic arguments.|
   * |func            |A function to copy all information from.       |
   *
   * |Thread Option Entry|Description                              |
   * |:-----------------:|:---------------------------------------:|
   * |script             |The script attached to the thread.       |
   * |identity           |The identity of the new state.           |
   * |env                |The global environment of the new thread.|
   * |thread             |A thread used as the parent.             |
   */
  function trampoline_call(target: Callback, call_stack: { currentline?: number; env?: { [key: string]: unknown }; source?: string; name?: string; numparams?: number; is_vararg?: boolean; func?: Callback }, thread_options: { script?: LuaSourceContainer; identity?: number; env?: { [key: string]: unknown }; thread?: thread }, ...args: unknown[]): LuaTuple<[boolean, ...(unknown | string)[]]>;
  /** Displays a toast notification in the internal UI. The options table follows the following format:
   * |Option   |Description                                      |Default       |
   * |:-------:|:-----------------------------------------------:|:------------:|
   * |Type     |{@link ToastType} enum                           |Required      |
   * |Duration |How long the notification should last, in seconds|5             |
   * |Title    |The notification's title                         |Required      |
   * |Content  |The notification's content                       |Required      |
   * |IconColor|Overrides the icon color                         |Varies by Type|
   */
  function toast_notification(options: { Type: ToastType; Duration?: number; Title: string; Content: string; IconColor?: Color3 }): void;
  /** Sends data to the UI. */
  function ipc_send(data: unknown): void;
  /** Makes a RESTful HTTP request.
   *
   *  **Request Options**
   * |Option |Description                                                                                                                                             |Default |
   * |:-----:|:------------------------------------------------------------------------------------------------------------------------------------------------------:|:------:|
   * |Url    |The request URL                                                                                                                                         |Required|
   * |Method |The request method                                                                                                                                      |"GET"   |
   * |Headers|A map of header names to header values                                                                                                                  |{}      |
   * |Cookies|A map of cookie names to cookie values                                                                                                                  |{}      |
   * |Body   |The request body. Cannot be used with GET or HEAD requests. It might be necessary to specify the Content-Type header when sending JSON or other formats.|nil     |
   *
   * **Synapse Headers**
   *
   * In addition to headers provided by the user, Synapse X adds the following:
   *
   * *Note*: `Syn-Fingerprint` and `Syn-User-Identifier` have been deprecated in favor of the new public key verification system shown below.
   * |Header             |Value                                                                   |Can Override|
   * |:-----------------:|:----------------------------------------------------------------------:|:----------:|
   * |User-Agent         |A string in the format "sx/<build_hash>".                               |Yes         |
   * |Syn-Signature      |Public-key authenticated headers, base64-encoded. See below for use.    |No          |
   * |Syn-Fingerprint    |A string value which uniquely identifies the computer running Synapse X.|No          |
   * |Syn-User-Identifier|A string value which uniquely identifies the current Synapse X user.    |No          |
   *
   * **Response Table**
   *
   * `syn.request` returns the following table once the request is complete:
   * |Key          |Description                           |
   * |:-----------:|:------------------------------------:|
   * |Success      |Whether the request succeeded         |
   * |StatusCode   |The HTTP status code of the response  |
   * |StatusMessage|A human-readable version of StatusCode|
   * |Headers      |The response headers                  |
   * |Cookies      |The response cookies                  |
   * |Body         |The response body                     |
   *
   * **Public Key Verification**
   *
   * Servers can verify a request was made by Synapse X via the public key verification system, along with `syn.crypt.user.sign` to verify extra data sent to the server.
   *
   * To verify a `Syn-Signature` header, you must use [libsodium]{@link https://libsodium.gitbook.io/doc/} with the [crypto_sign_open]{@link https://libsodium.gitbook.io/doc/public-key_cryptography/public-key_signatures#combined-mode} function. Pass `qgq26x4+4FWdLzRpGZytZfEQJlOeusryQC8ppC2BEVA=` (Base64 encoded) as the public key. We will always alert developers and users if this key ever changes.
   *
   * After signature verification succeeds, you will get a JSON encoded payload with the following fields:
   * |Field              |Description                                                                                                                                                                                                                                                                                                                                                 |
   * |:-----------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
   * |authenticationTime |UNIX timestamp when the user authenticated this instance (UTC).                                                                                                                                                                                                                                                                                             |
   * |fingerprint        |Same as the `Syn-Fingerprint` legacy header.                                                                                                                                                                                                                                                                                                                |
   * |ipAddress          |The IP address that was used to authenticate this instance. Please note this can change if the user was using a mobile network/similar. Can be IPv4 or IPv6.                                                                                                                                                                                                |
   * |userIdentifier     |Same as the `Syn-User-Identifier` legacy header.                                                                                                                                                                                                                                                                                                            |
   * |userPublicKey      |The Base64 encoded public key for this user. You can use this to verify messages that were signed with the `syn.crypt.user.sign` function. To verify messages, use the libsodium [crypto_sign_verify_detached]{@link https://libsodium.gitbook.io/doc/public-key_cryptography/public-key_signatures#detached-mode} function with this key as the public key.|
   * |userPromptPublicKey|The Base64 encoded prompt public key for this user. Like the above public key, this can be used to verify messages that were signed with the `syn.crypt.user.prompt.sign` function.                                                                                                                                                                         |
   *
   * Please note that *new* fields can be added to this JSON payload at any time, so don't rely on the above for your JSON schemas. We will never remove fields without first alerting developers, though.
   */
  function request(params: { Url: string; Method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH"; Headers: object; Cookies: object; Body: object | undefined }): { Success: boolean; StatusCode: number; StatusMessage: string; Headers: object; Cookies: object; Body: object | undefined };
  /** Schedules code to be executed on an actor's Lua state. */
  function run_on_actor(actor: Actor, source: string, ...args: unknown[]): boolean;
  // TODO: figure out how to specify args for events
  /** Fired upon actor Lua state creation, before any scripts are ran. */
  const on_actor_state_created: SynSignal;
}
